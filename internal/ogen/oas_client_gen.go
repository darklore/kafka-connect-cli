// Code generated by ogen, DO NOT EDIT.

package ogen

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.26.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CreateConnector invokes createConnector operation.
	//
	// Create a new connector.
	//
	// POST /connectors
	CreateConnector(ctx context.Context, request OptCreateConnectorRequest) (*ConnectorInfoStatusCode, error)
	// GetConnector invokes getConnector operation.
	//
	// Get the details for the specified connector.
	//
	// GET /connectors/{connector}
	GetConnector(ctx context.Context, params GetConnectorParams) (*ConnectorInfoStatusCode, error)
	// GetConnectorActiveTopics invokes getConnectorActiveTopics operation.
	//
	// Get the list of topics actively used by the specified connector.
	//
	// GET /connectors/{connector}/topics
	GetConnectorActiveTopics(ctx context.Context, params GetConnectorActiveTopicsParams) (*ConnectorActiveTopicsStatusCode, error)
	// GetConnectorConfig invokes getConnectorConfig operation.
	//
	// Get the configuration for the specified connector.
	//
	// GET /connectors/{connector}/config
	GetConnectorConfig(ctx context.Context, params GetConnectorConfigParams) (*GetConnectorConfigDefStatusCode, error)
	// GetConnectorConfigDef invokes getConnectorConfigDef operation.
	//
	// Get the configuration definition for the specified pluginName.
	//
	// GET /connector-plugins/{pluginName}/config
	GetConnectorConfigDef(ctx context.Context, params GetConnectorConfigDefParams) (*GetConnectorConfigDefDefStatusCode, error)
	// GetConnectorStatus invokes getConnectorStatus operation.
	//
	// Get the status for the specified connector.
	//
	// GET /connectors/{connector}/status
	GetConnectorStatus(ctx context.Context, params GetConnectorStatusParams) (*ConnectorStateInfoStatusCode, error)
	// GetOffsets invokes getOffsets operation.
	//
	// Get the current offsets for the specified connector.
	//
	// GET /connectors/{connector}/offsets
	GetOffsets(ctx context.Context, params GetOffsetsParams) (*ConnectorOffsetsStatusCode, error)
	// GetTaskConfigs invokes getTaskConfigs operation.
	//
	// List all tasks and their configurations for the specified connector.
	//
	// GET /connectors/{connector}/tasks
	GetTaskConfigs(ctx context.Context, params GetTaskConfigsParams) (*GetTaskConfigsDefStatusCode, error)
	// GetTaskStatus invokes getTaskStatus operation.
	//
	// Get the state of the specified task for the specified connector.
	//
	// GET /connectors/{connector}/tasks/{task}/status
	GetTaskStatus(ctx context.Context, params GetTaskStatusParams) (*TaskStateStatusCode, error)
	// GetTasksConfig invokes getTasksConfig operation.
	//
	// Get the configuration of all tasks for the specified connector.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /connectors/{connector}/tasks-config
	GetTasksConfig(ctx context.Context, params GetTasksConfigParams) (*GetTasksConfigDefStatusCode, error)
	// ListConnectorPlugins invokes listConnectorPlugins operation.
	//
	// List all connector plugins installed.
	//
	// GET /connector-plugins
	ListConnectorPlugins(ctx context.Context, params ListConnectorPluginsParams) (*ListConnectorPluginsDefStatusCode, error)
	// ListConnectors invokes listConnectors operation.
	//
	// List all active connectors.
	//
	// GET /connectors
	ListConnectors(ctx context.Context) (*ListConnectorsDefStatusCode, error)
	// PutConnectorConfig invokes putConnectorConfig operation.
	//
	// Create or reconfigure the specified connector.
	//
	// PUT /connectors/{connector}/config
	PutConnectorConfig(ctx context.Context, request OptConnectorConfig, params PutConnectorConfigParams) (*ConnectorInfoStatusCode, error)
	// ServerInfo invokes serverInfo operation.
	//
	// Get details about this Connect worker and the ID of the Kafka cluster it is connected to.
	//
	// GET /
	ServerInfo(ctx context.Context) (*ServerInfoStatusCode, error)
	// ValidateConfigs invokes validateConfigs operation.
	//
	// Validate the provided configuration against the configuration definition for the specified
	// pluginName.
	//
	// PUT /connector-plugins/{pluginName}/config/validate
	ValidateConfigs(ctx context.Context, request OptValidateConfigsReq, params ValidateConfigsParams) (*ConfigInfosStatusCode, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	baseClient
}

var _ Handler = struct {
	*Client
}{}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CreateConnector invokes createConnector operation.
//
// Create a new connector.
//
// POST /connectors
func (c *Client) CreateConnector(ctx context.Context, request OptCreateConnectorRequest) (*ConnectorInfoStatusCode, error) {
	res, err := c.sendCreateConnector(ctx, request)
	return res, err
}

func (c *Client) sendCreateConnector(ctx context.Context, request OptCreateConnectorRequest) (res *ConnectorInfoStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("createConnector"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/connectors"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, CreateConnectorOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/connectors"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateConnectorRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeCreateConnectorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConnector invokes getConnector operation.
//
// Get the details for the specified connector.
//
// GET /connectors/{connector}
func (c *Client) GetConnector(ctx context.Context, params GetConnectorParams) (*ConnectorInfoStatusCode, error) {
	res, err := c.sendGetConnector(ctx, params)
	return res, err
}

func (c *Client) sendGetConnector(ctx context.Context, params GetConnectorParams) (res *ConnectorInfoStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getConnector"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connectors/{connector}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConnectorOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/connectors/"
	{
		// Encode "connector" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connector",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Connector))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConnectorResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConnectorActiveTopics invokes getConnectorActiveTopics operation.
//
// Get the list of topics actively used by the specified connector.
//
// GET /connectors/{connector}/topics
func (c *Client) GetConnectorActiveTopics(ctx context.Context, params GetConnectorActiveTopicsParams) (*ConnectorActiveTopicsStatusCode, error) {
	res, err := c.sendGetConnectorActiveTopics(ctx, params)
	return res, err
}

func (c *Client) sendGetConnectorActiveTopics(ctx context.Context, params GetConnectorActiveTopicsParams) (res *ConnectorActiveTopicsStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getConnectorActiveTopics"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connectors/{connector}/topics"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConnectorActiveTopicsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connectors/"
	{
		// Encode "connector" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connector",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Connector))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/topics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConnectorActiveTopicsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConnectorConfig invokes getConnectorConfig operation.
//
// Get the configuration for the specified connector.
//
// GET /connectors/{connector}/config
func (c *Client) GetConnectorConfig(ctx context.Context, params GetConnectorConfigParams) (*GetConnectorConfigDefStatusCode, error) {
	res, err := c.sendGetConnectorConfig(ctx, params)
	return res, err
}

func (c *Client) sendGetConnectorConfig(ctx context.Context, params GetConnectorConfigParams) (res *GetConnectorConfigDefStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getConnectorConfig"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connectors/{connector}/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConnectorConfigOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connectors/"
	{
		// Encode "connector" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connector",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Connector))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConnectorConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConnectorConfigDef invokes getConnectorConfigDef operation.
//
// Get the configuration definition for the specified pluginName.
//
// GET /connector-plugins/{pluginName}/config
func (c *Client) GetConnectorConfigDef(ctx context.Context, params GetConnectorConfigDefParams) (*GetConnectorConfigDefDefStatusCode, error) {
	res, err := c.sendGetConnectorConfigDef(ctx, params)
	return res, err
}

func (c *Client) sendGetConnectorConfigDef(ctx context.Context, params GetConnectorConfigDefParams) (res *GetConnectorConfigDefDefStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getConnectorConfigDef"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connector-plugins/{pluginName}/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConnectorConfigDefOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connector-plugins/"
	{
		// Encode "pluginName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pluginName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PluginName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConnectorConfigDefResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetConnectorStatus invokes getConnectorStatus operation.
//
// Get the status for the specified connector.
//
// GET /connectors/{connector}/status
func (c *Client) GetConnectorStatus(ctx context.Context, params GetConnectorStatusParams) (*ConnectorStateInfoStatusCode, error) {
	res, err := c.sendGetConnectorStatus(ctx, params)
	return res, err
}

func (c *Client) sendGetConnectorStatus(ctx context.Context, params GetConnectorStatusParams) (res *ConnectorStateInfoStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getConnectorStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connectors/{connector}/status"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetConnectorStatusOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connectors/"
	{
		// Encode "connector" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connector",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Connector))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetConnectorStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOffsets invokes getOffsets operation.
//
// Get the current offsets for the specified connector.
//
// GET /connectors/{connector}/offsets
func (c *Client) GetOffsets(ctx context.Context, params GetOffsetsParams) (*ConnectorOffsetsStatusCode, error) {
	res, err := c.sendGetOffsets(ctx, params)
	return res, err
}

func (c *Client) sendGetOffsets(ctx context.Context, params GetOffsetsParams) (res *ConnectorOffsetsStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getOffsets"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connectors/{connector}/offsets"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetOffsetsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connectors/"
	{
		// Encode "connector" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connector",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Connector))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/offsets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetOffsetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTaskConfigs invokes getTaskConfigs operation.
//
// List all tasks and their configurations for the specified connector.
//
// GET /connectors/{connector}/tasks
func (c *Client) GetTaskConfigs(ctx context.Context, params GetTaskConfigsParams) (*GetTaskConfigsDefStatusCode, error) {
	res, err := c.sendGetTaskConfigs(ctx, params)
	return res, err
}

func (c *Client) sendGetTaskConfigs(ctx context.Context, params GetTaskConfigsParams) (res *GetTaskConfigsDefStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTaskConfigs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connectors/{connector}/tasks"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTaskConfigsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connectors/"
	{
		// Encode "connector" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connector",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Connector))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTaskConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTaskStatus invokes getTaskStatus operation.
//
// Get the state of the specified task for the specified connector.
//
// GET /connectors/{connector}/tasks/{task}/status
func (c *Client) GetTaskStatus(ctx context.Context, params GetTaskStatusParams) (*TaskStateStatusCode, error) {
	res, err := c.sendGetTaskStatus(ctx, params)
	return res, err
}

func (c *Client) sendGetTaskStatus(ctx context.Context, params GetTaskStatusParams) (res *TaskStateStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTaskStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connectors/{connector}/tasks/{task}/status"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTaskStatusOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/connectors/"
	{
		// Encode "connector" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connector",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Connector))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "task" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "task",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.Task))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTaskStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTasksConfig invokes getTasksConfig operation.
//
// Get the configuration of all tasks for the specified connector.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /connectors/{connector}/tasks-config
func (c *Client) GetTasksConfig(ctx context.Context, params GetTasksConfigParams) (*GetTasksConfigDefStatusCode, error) {
	res, err := c.sendGetTasksConfig(ctx, params)
	return res, err
}

func (c *Client) sendGetTasksConfig(ctx context.Context, params GetTasksConfigParams) (res *GetTasksConfigDefStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("getTasksConfig"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connectors/{connector}/tasks-config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, GetTasksConfigOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connectors/"
	{
		// Encode "connector" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connector",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Connector))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks-config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeGetTasksConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListConnectorPlugins invokes listConnectorPlugins operation.
//
// List all connector plugins installed.
//
// GET /connector-plugins
func (c *Client) ListConnectorPlugins(ctx context.Context, params ListConnectorPluginsParams) (*ListConnectorPluginsDefStatusCode, error) {
	res, err := c.sendListConnectorPlugins(ctx, params)
	return res, err
}

func (c *Client) sendListConnectorPlugins(ctx context.Context, params ListConnectorPluginsParams) (res *ListConnectorPluginsDefStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listConnectorPlugins"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connector-plugins"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListConnectorPluginsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/connector-plugins"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "connectorsOnly" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "connectorsOnly",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ConnectorsOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListConnectorPluginsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ListConnectors invokes listConnectors operation.
//
// List all active connectors.
//
// GET /connectors
func (c *Client) ListConnectors(ctx context.Context) (*ListConnectorsDefStatusCode, error) {
	res, err := c.sendListConnectors(ctx)
	return res, err
}

func (c *Client) sendListConnectors(ctx context.Context) (res *ListConnectorsDefStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("listConnectors"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/connectors"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ListConnectorsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/connectors"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeListConnectorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PutConnectorConfig invokes putConnectorConfig operation.
//
// Create or reconfigure the specified connector.
//
// PUT /connectors/{connector}/config
func (c *Client) PutConnectorConfig(ctx context.Context, request OptConnectorConfig, params PutConnectorConfigParams) (*ConnectorInfoStatusCode, error) {
	res, err := c.sendPutConnectorConfig(ctx, request, params)
	return res, err
}

func (c *Client) sendPutConnectorConfig(ctx context.Context, request OptConnectorConfig, params PutConnectorConfigParams) (res *ConnectorInfoStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("putConnectorConfig"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/connectors/{connector}/config"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PutConnectorConfigOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connectors/"
	{
		// Encode "connector" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "connector",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Connector))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePutConnectorConfigRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePutConnectorConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServerInfo invokes serverInfo operation.
//
// Get details about this Connect worker and the ID of the Kafka cluster it is connected to.
//
// GET /
func (c *Client) ServerInfo(ctx context.Context) (*ServerInfoStatusCode, error) {
	res, err := c.sendServerInfo(ctx)
	return res, err
}

func (c *Client) sendServerInfo(ctx context.Context) (res *ServerInfoStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("serverInfo"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ServerInfoOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeServerInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ValidateConfigs invokes validateConfigs operation.
//
// Validate the provided configuration against the configuration definition for the specified
// pluginName.
//
// PUT /connector-plugins/{pluginName}/config/validate
func (c *Client) ValidateConfigs(ctx context.Context, request OptValidateConfigsReq, params ValidateConfigsParams) (*ConfigInfosStatusCode, error) {
	res, err := c.sendValidateConfigs(ctx, request, params)
	return res, err
}

func (c *Client) sendValidateConfigs(ctx context.Context, request OptValidateConfigsReq, params ValidateConfigsParams) (res *ConfigInfosStatusCode, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("validateConfigs"),
		semconv.HTTPRequestMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/connector-plugins/{pluginName}/config/validate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ValidateConfigsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/connector-plugins/"
	{
		// Encode "pluginName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pluginName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PluginName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/config/validate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeValidateConfigsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeValidateConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
